<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Himalayan 3D Cave Escape</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: white; z-index: 10; pointer-events: none; }
        .stats-box { background: rgba(0, 0, 0, 0.6); padding: 10px 20px; border-radius: 15px; border: 1px solid #00ffcc; display: inline-block; }
        #overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 100; text-align: center; }
        button { padding: 20px 50px; font-size: 24px; cursor: pointer; background: linear-gradient(45deg, #ff9800, #ff5722); color: white; border: none; border-radius: 50px; font-weight: bold; box-shadow: 0 5px 20px rgba(255,87,34,0.5); }
        .progress-bar { width: 250px; height: 10px; background: #333; border-radius: 5px; margin: 10px auto; overflow: hidden; }
        #fill { width: 0%; height: 100%; background: #00ffcc; transition: width 0.3s; }
    </style>
</head>
<body>

<div id="ui">
    <div class="stats-box">
        <div id="lvlName" style="font-size: 24px; color: #00ffcc; font-weight: bold;">Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1</div>
        <div class="progress-bar"><div id="fill"></div></div>
        <div style="font-size: 18px;">ğŸ  <span id="fCount">0</span> | ğŸº Ø§Ù„Ù…Ø³Ø§ÙØ©: <span id="dCount">1000</span>m</div>
    </div>
</div>

<div id="overlay">
    <h1 style="font-size: 40px;">Ø§Ù„Ù‡Ø±ÙˆØ¨ Ù…Ù† Ø§Ù„ÙƒÙ‡Ù 3D ğŸ¾</h1>
    <p style="font-size: 20px; margin-bottom: 30px;">Ø³Ø§Ø¹Ø¯ Ø§Ù„Ù‚Ø·Ø© Ø¹Ù„Ù‰ ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚ ÙˆØ§Ù„Ù‡Ø±ÙˆØ¨ Ù…Ù† Ø§Ù„Ø°Ø¦Ø§Ø¨!</p>
    <button onclick="startGame()">Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ­Ø¯ÙŠ ğŸ®</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, cat, wolf, floor, obstacles = [], fishes = [];
    let active = false, level = 0, score = 0, distance = 1000;
    let clock = new THREE.Clock();

    function init() {
        // 1. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x050505, 10, 50);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© (Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„ÙƒÙ‡Ù Ø§Ù„Ù…Ù„ÙˆÙ†Ø©)
        const light = new THREE.PointLight(0x00ffcc, 2, 50);
        light.position.set(0, 10, 0);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 3. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‚Ø·Ø© (Ù…Ø¬Ø³Ù… 3D Ù…Ø¨Ø³Ø·)
        const catGroup = new THREE.Group();
        const bodyGeo = new THREE.BoxGeometry(1.5, 1, 2);
        const bodyMat = new THREE.MeshPhongMaterial({ color: 0xFDF5E6 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        catGroup.add(body);

        const headGeo = new THREE.BoxGeometry(1, 1, 1);
        const headMat = new THREE.MeshPhongMaterial({ color: 0x4E342E });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.set(0, 0.5, 1.2);
        catGroup.add(head);

        cat = catGroup;
        cat.position.y = 0.5;
        scene.add(cat);

        // 4. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙˆØ­Ø´ (Ø§Ù„Ø°Ø¦Ø¨)
        const wolfGeo = new THREE.BoxGeometry(2, 1.5, 3);
        const wolfMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
        wolf = new THREE.Mesh(wolfGeo, wolfMat);
        wolf.position.set(0, 0.75, -10);
        scene.add(wolf);

        // 5. Ø§Ù„Ø£Ø±Ø¶ÙŠØ© (Ø§Ù„ÙƒÙ‡Ù)
        const floorGeo = new THREE.PlaneGeometry(100, 1000);
        const floorMat = new THREE.MeshPhongMaterial({ color: 0x111111, side: THREE.DoubleSide });
        floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = Math.PI / 2;
        scene.add(floor);

        animate();
    }

    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        active = true;
        distance = 1000;
        level = 0;
    }

    function animate() {
        requestAnimationFrame(animate);
        
        if (active) {
            let delta = clock.getDelta();
            
            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø£Ø±Ø¶ÙŠØ© Ù„ØªØ¨Ø¯Ùˆ Ø§Ù„Ù‚Ø·Ø© ÙˆÙƒØ£Ù†Ù‡Ø§ ØªØ±ÙƒØ¶
            floor.position.z += 0.2 + (level * 0.05);
            if (floor.position.z > 50) floor.position.z = 0;

            // Ù…Ø·Ø§Ø±Ø¯Ø© Ø§Ù„Ø°Ø¦Ø¨
            wolf.position.z = Math.min(cat.position.z - 5, wolf.position.z + 0.15);
            wolf.position.x = Math.sin(Date.now() * 0.002) * 2; // Ø­Ø±ÙƒØ© Ù…ØªØ¹Ø±Ø¬Ø© Ù„Ù„Ø°Ø¦Ø¨

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
            distance -= 0.5;
            document.getElementById('dCount').innerText = Math.floor(distance);
            document.getElementById('fill').style.width = (1 - distance/1000)*100 + "%";

            if (distance <= 0) {
                level++;
                distance = 1000;
                document.getElementById('lvlName').innerText = "Ø§Ù„Ù…Ø±Ø­Ù„Ø© " + (level + 1);
            }
        }

        renderer.render(scene, camera);
    }

    // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ ÙˆØ§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && cat.position.y <= 0.6) {
            cat.position.y += 3; // Ù‚ÙØ²Ø© Ø¨Ø³ÙŠØ·Ø© 3D
            setTimeout(() => cat.position.y = 0.5, 500);
        }
    });

    window.addEventListener('touchstart', () => {
        if (cat.position.y <= 0.6) {
            cat.position.y += 3;
            setTimeout(() => cat.position.y = 0.5, 500);
        }
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>